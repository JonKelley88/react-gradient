import React from 'react';

function hexToRGB(color) {
  const numericString = color.substring(1);
  return [// parse the R value
  parseInt(numericString.substring(0, 2), 16), // parse the G value
  parseInt(numericString.substring(2, 4), 16), // parse the B value
  parseInt(numericString.substring(4), 16)];
}

function rgbStringToRGB(color) {
  const openParen = color.indexOf('(') + 1;
  const closeParen = color.indexOf(')');
  const numericString = color.substring(openParen, closeParen);
  return numericString.split(',').map(num => +num);
}

function convertToRGB(gradients) {
  const rgbArray = gradients.map(gradient => {
    return gradient.map(color => {
      // if the color is a 6-digit hex
      if (color.charAt(0) === '#' && color.length === 7) return hexToRGB(color); // if the color is already rgb (string)

      if (color.startsWith('rgb(')) return rgbStringToRGB(color);
    });
  });
  return rgbArray;
}

function calculateProperties({
  gradients,
  propertyList,
  cycle,
  counter,
  gradientType,
  duration
}) {
  const propertiesObject = {};
  const sourceGradient = gradients[cycle];
  const targetGradient = cycle === gradients.length - 1 ? gradients[0] : gradients[cycle + 1];
  const transitionProgress = (counter * 100 / duration).toFixed(3);
  const leftDifference = sourceGradient[0].map((num, idx) => num - targetGradient[0][idx]);
  const rightDifference = sourceGradient[1].map((num, idx) => num - targetGradient[1][idx]);
  const leftInterpolation = leftDifference.map(num => transitionProgress * num / 100);
  const rightInterpolation = rightDifference.map(num => transitionProgress * num / 100);
  const leftValues = sourceGradient[0].map((num, idx) => Math.round(num - leftInterpolation[idx]));
  const rightValues = sourceGradient[1].map((num, idx) => Math.round(num - rightInterpolation[idx]));

  const interpolateValues = function () {
    return `rgb(${leftValues}), rgb(${rightValues})`;
  };

  propertyList.forEach(property => {
    propertiesObject[property] = `${gradientType}-gradient(${interpolateValues()})`;
  });
  return propertiesObject;
}

class Gradient extends React.Component {
  constructor(props) {
    super(props);
    this.properties = {};
    this.rgbGradients = convertToRGB(props.gradients);
    this.lastCycle = props.gradients.length - 1;
    this.duration = props.duration || 3000;
    this.gradientType = props.gradientType || 'linear';
    this.animationId = undefined;
    this.animate = this.animate.bind(this);
    this.state = {
      currentCycle: 0,
      counter: 0
    };
  }

  componentDidMount() {
    window.requestAnimationFrame(this.animate);
  }

  componentWillUnmount() {
    window.cancelAnimationFrame(this.animationId);
  }

  animate() {
    const {
      counter,
      currentCycle
    } = this.state;
    const updatedCounter = counter >= this.duration ? 0 : counter + 16;
    const updatedCycle = currentCycle === this.lastCycle ? 0 : currentCycle + 1;
    this.properties = calculateProperties({
      gradients: this.rgbGradients,
      propertyList: this.props.properties,
      duration: this.duration,
      cycle: currentCycle,
      gradientType: this.gradientType,
      counter
    });

    if (updatedCounter === 0) {
      this.setState({
        currentCycle: updatedCycle,
        counter: updatedCounter
      });
    } else {
      this.setState({
        counter: updatedCounter
      });
    }

    this.animationId = window.requestAnimationFrame(this.animate);
  }

  render() {
    const {
      children
    } = this.props;
    return React.createElement("div", {
      className: "animate-gradient",
      style: this.properties
    }, children);
  }

}

export { Gradient };
